from __future__ import annotations

import random
from typing import TYPE_CHECKING

import napari
import numpy as np
if TYPE_CHECKING:
    from motile_tracker.data_views.views_coordinator.tracks_viewer import TracksViewer
from motile_toolbox.candidate_graph.graph_attributes import NodeAttr


class TrackLabels(napari.layers.Labels):
    """Extended labels layer that holds the track information and emits
    and responds to dynamics visualization signals"""

    @property
    def _type_string(self) -> str:
        return "labels"  # to make sure that the layer is treated as labels layer for saving

    def __init__(
        self,
        viewer: napari.Viewer,
        data: np.array,
        name: str,
        opacity: float,
        scale: tuple,
        tracks_viewer: TracksViewer,
    ):
        self.viewer = viewer
        self.visible_nodes = "all"
        self.highlighted = []
        self.tracks_viewer = tracks_viewer
        self.node_properties = self._get_node_properties()
        self.current_track_id = 1

        super().__init__(
            data=data,
            name=name,
            opacity=opacity,
            colormap=tracks_viewer.colormap,
            scale=scale,
        )
        self._get_current_track_id()
        self.events.selected_label.connect(self._get_current_track_id)


        # Key bindings (should be specified both on the viewer (in tracks_viewer)
        # and on the layer to overwrite napari defaults)
        self.bind_key("q")(self.tracks_viewer.toggle_display_mode)
        self.bind_key("a")(self.tracks_viewer.create_edge)
        self.bind_key("d")(self.tracks_viewer.delete_node)
        self.bind_key("Delete")(self.tracks_viewer.delete_node)
        self.bind_key("b")(self.tracks_viewer.delete_edge)
        # self.bind_key("s")(self.tracks_viewer.set_split_node)
        # self.bind_key("e")(self.tracks_viewer.set_endpoint_node)
        # self.bind_key("c")(self.tracks_viewer.set_linear_node)
        self.bind_key("z")(self.tracks_viewer.undo)
        self.bind_key("r")(self.tracks_viewer.redo)

    def _get_current_track_id(self):
        if self.selected_label in self.node_properties["node_id"]:
            self.current_track_id = self.tracks_viewer.tracks.get_track_id(self.selected_label)
        print(f"{self.selected_label=} {self.current_track_id=}")

        # Connect click events to node selection
        @self.mouse_drag_callbacks.append
        def click(_, event):
            if (
                event.type == "mouse_press"
                and self.mode == "pan_zoom"
                and not (
                    self.tracks_viewer.mode == "lineage"
                    and self.viewer.dims.ndisplay == 3
                )
            ):  # disable selecting in lineage mode in 3D
                label = self.get_value(
                    event.position,
                    view_direction=event.view_direction,
                    dims_displayed=event.dims_displayed,
                    world=True,
                )

                if (
                    label is not None
                    and label != 0
                    and self._is_visible(label)
                ):  # check opacity (=visibility) in the colormap
                    append = "Shift" in event.modifiers
                    self.tracks_viewer.selected_nodes.add(label, append)

        # Listen to paint events and changing the selected label
        self.events.paint.connect(self._on_paint)
        self.tracks_viewer.selected_nodes.list_updated.connect(
            self.update_selected_label
        )
        self.events.selected_label.connect(self._ensure_valid_label)
        self.viewer.dims.events.current_step.connect(self._ensure_valid_label)

    def _get_node_properties(self):
        tracks = self.tracks_viewer.tracks
        if tracks is not None:
            nodes = list(tracks.graph.nodes())
            track_ids = [tracks.get_track_id(node) for node in nodes]
            times = tracks.get_times(nodes)
        else:
            nodes = []
            track_ids = []
            times = []
            colors = []
        return {"node_id": nodes, "track_id": track_ids, "t": times}

    def redo(self):
        """Overwrite the redo functionality of the labels layer and invoke redo action on the tracks_viewer.tracks_controller first"""

        self.tracks_viewer.redo()

    def undo(self):
        """Overwrite undo function and invoke undo action on the tracks_viewer.tracks_controller"""

        self.tracks_viewer.undo()

    def _parse_paint_event(self, event_val):
        """_summary_

        Args:
            event_val (list[tuple]): A list of paint "atoms" generated by the labels layer.
                Each atom is a 3-tuple of arrays containing:
                - a numpy multi-index, pointing to the array elements that were
                changed (a tuple with len ndims)
                - the values corresponding to those elements before the change
                - the value after the change
        Returns:
            tuple(int, list[tuple]): The new value, and a list of node update actions
                defined by the time point and node update item
                Each "action" is a 2-tuple containing:
                - a numpy multi-index, pointing to the array elements that were
                changed (a tuple with len ndims)
                - the value before the change
        """
        new_value = event_val[-1][-1]
        ndim = len(event_val[-1][0])
        concatenated_indices = tuple(
            np.concatenate([ev[0][dim] for ev in event_val]) for dim in range(ndim)
        )
        concatenated_values = np.concatenate([ev[1] for ev in event_val])
        old_values = np.unique(concatenated_values)
        actions = []
        for old_value in old_values:
            mask = concatenated_values == old_value
            indices = tuple(concatenated_indices[dim][mask] for dim in range(ndim))
            time_points = np.unique(indices[0])
            for time in time_points:
                time_mask = indices[0] == time
                actions.append(
                    (tuple(indices[dim][time_mask] for dim in range(ndim)), old_value)
                )
        return new_value, actions

    def _on_paint(self, event):
        """Listen to the paint event and check which track_ids have changed"""

        current_timepoint = self.viewer.dims.current_step[
            0
        ]  # also pass on the current time point to know which node to select later
        new_value, updated_pixels = self._parse_paint_event(event.value)
        # updated_pixels is a list of tuples. Each tuple is (indices, old_value)
        to_delete = []  # (node_ids, pixels)
        to_update_smaller = []  # (node_id, pixels)
        to_update_bigger = []  # (node_id, pixels)
        to_add = []  # (track_id, pixels)
        for pixels, old_value in updated_pixels:
            ndim = len(pixels)
            if old_value == 0:
                continue
            time = pixels[0][0]
            removed_node = old_value
            assert (
                removed_node is not None
            ), f"Node with label {old_value} in time {time} was not found"
            # check if all pixels of old_value are removed
            if np.sum(self.data[time] == old_value) == 0:
                to_delete.append((removed_node, pixels))
            else:
                to_update_smaller.append((removed_node, pixels))
        if new_value != 0:
            all_pixels = tuple(
                np.concatenate([pixels[dim] for pixels, _ in updated_pixels])
                for dim in range(ndim)
            )
            for _ in np.unique(all_pixels[0]):
                existing_node = self.tracks_viewer.tracks.graph.has_node(new_value)
                if existing_node:
                    to_update_bigger.append((new_value, all_pixels))
                else:
                    to_add.append((new_value, self.current_track_id, all_pixels))

        self.tracks_viewer.tracks_controller.update_segmentations(
            to_delete, to_update_smaller, to_update_bigger, to_add, current_timepoint
        )

    def _refresh(self):
        """Refresh the data in the labels layer"""

        self.data = self.tracks_viewer.tracks.segmentation
        self.node_properties = self._get_node_properties()
        self.refresh()

    def update_visible(self, visible_tracks, visible_nodes: list[int] | str) -> None:
        """Updates the opacity of the label colormap to highlight the selected label
        and optionally hide cells not belonging to the current lineage

        Visible is a list of visible node ids"""

        self.highlighted = self.tracks_viewer.selected_nodes
        self.visible_nodes = visible_nodes
        self.refresh()

    def new_colormap(self):
        """Replace existing function, to generate new colormap and emit refresh signal to also update colors in other layers/widgets"""

        self.tracks_viewer.colormap = napari.utils.colormaps.label_colormap(
            49,
            seed=random.uniform(0, 1),
            background_value=0,
        )
        self.tracks_viewer._refresh()

    def update_selected_label(self):
        """Update the selected label in the labels layer"""

        if len(self.tracks_viewer.selected_nodes) > 0:
            self.selected_label = self.tracks_viewer.selected_nodes[0]

    def _ensure_valid_label(self, event):
        """Make sure a valid label is selected, because it is not allowed to paint with a label that already exists at a different timepoint.
        Scenarios:
        1. If a node with the selected label value (node id) exists at a different time point, check if there is any node with the same track_id at the current time point
            1.a if there is a node with the same track id, select that one, so that it can be used to update an existing node
            1.b if there is no node with the same track id, and the node_id value does not yet exist in the colormap dict, create a new node id and paint with the track_id of the selected label. Make sure to add it to the colormap dict. This can be used to add a new node with the same track id at a time point where it does not (yet) exist (anymore).
        2. if there is no existing node with this value in the graph, but the node id is in the colormap dict, it means that the node was created but has not been used to paint with. Retrieve the track_id from self.current_track_id and use it to find if there are any nodes of this track id at current time point
        3. If no node with this label exists yet, it is valid and can be used to start a new track id. Therefore, create a new node id and map a new color. Add it to the dictionary.
        4. If a node with the label exists at the current time point, it is valid and can be used to update the existing node in a paint event. No action is needed"""

        self.events.selected_label.disconnect(self._ensure_valid_label)
        if self.tracks_viewer.tracks is not None:
            current_timepoint = self.viewer.dims.current_step[0]
            t_values = np.array(self.node_properties["t"])
            node_ids = np.array(self.node_properties["node_id"])

            # check if a node with this node id exists anywhere
            index = np.where(
                (t_values == current_timepoint) & (node_ids == self.selected_label)
            )[0]

            if len(index) == 0:
                if self.tracks_viewer.tracks.graph.has_node(
                    self.selected_label
                ):  # selected label is not valid, select the nearest available one
                    self.current_track_id = self.tracks_viewer.tracks._get_node_attr(
                        self.selected_label, NodeAttr.TRACK_ID.value
                    )

                    # is there any node with this track id at the current timepoint?
                    time_point_nodes = [
                        node
                        for node in self.tracks_viewer.tracks.graph.nodes()
                        if self.tracks_viewer.tracks.get_time(node) == current_timepoint
                    ]
                    track_id_nodes = [
                        node
                        for node in time_point_nodes
                        if self.tracks_viewer.tracks._get_node_attr(
                            node, NodeAttr.TRACK_ID.value
                        )
                        == self.current_track_id
                    ]

                    if len(track_id_nodes) > 0:
                        self.selected_label = track_id_nodes[
                            0
                        ]  # select the node with the same track id at the current time point
                    else:
                        self.selected_label = (
                            np.max(self.data) + 1
                        )  # pick an entirely new label, but use the same track id (color) by adding it to the colordict


                # the current node does not exist in the graph. Find out if it should belong to a new track or if it belongs to an existing track id but has not been painted yet
                # elif self.selected_label in self.colormap.color_dict:
                #     # is there a node with the associated track id at the current time point?
                #     time_point_nodes = [
                #         node
                #         for node in self.tracks_viewer.tracks.graph.nodes()
                #         if self.tracks_viewer.tracks.get_time(node) == current_timepoint
                #     ]
                #     track_id_nodes = [
                #         node
                #         for node in time_point_nodes
                #         if self.tracks_viewer.tracks._get_node_attr(
                #             node, NodeAttr.TRACK_ID.value
                #         )
                #         == self.current_track_id
                #     ]

                #     if len(track_id_nodes) > 0:
                #         self.selected_label = track_id_nodes[0]

                # The currently selected_label does not exist in the graph, it should be a new track
                else:
                    # this node should belong to a new track
                    new_track_id = self.tracks_viewer.tracks.get_next_track_id()
                    self.current_track_id = new_track_id
        self.events.selected_label.connect(self._ensure_valid_label)

    def _is_visible(self, label):
        if label is None:
            return False
        elif self.show_selected_label and label != self.selected_label:
            return False
        elif self.visible_nodes == "all":
            return True
        elif label in self.visible_nodes:
            return True
        else:
            return False

    def get_color(self, label):
        """Return the color corresponding to a specific node id. Maps through track id"""
        if label == self.colormap.background_value:
            col = None
        elif not self._is_visible(label):
            col = self.colormap.map(self.colormap.background_value)
        # elif label == self.selected_label:
        #     print(f"{self.current_track_id=}")
        #     col = self.colormap.map(self.current_track_id)
        else:
            col = self.colormap.map(self.tracks_viewer.tracks.get_track_id(label))
        if label in self.highlighted:
            col[-1] = 1.0
        else:
            col[-1] = 0.6

        print(f"label {label} is visible {self._is_visible(label)} has track id {self.tracks_viewer.tracks.get_track_id(label)} color {col}")

        return col